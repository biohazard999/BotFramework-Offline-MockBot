"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _reactScrollToBottom = require("react-scroll-to-bottom");

var _reactRedux = require("react-redux");

var _glamor = require("glamor");

var _memoizeOne = _interopRequireDefault(require("memoize-one"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _botframeworkWebchatCore = require("botframework-webchat-core");

var _concatMiddleware = _interopRequireDefault(require("./Middleware/concatMiddleware"));

var _Context = _interopRequireDefault(require("./Context"));

var _createCoreMiddleware = _interopRequireDefault(require("./Middleware/CardAction/createCoreMiddleware"));

var _createStyleSet = _interopRequireDefault(require("./Styles/createStyleSet"));

var _Dictation = _interopRequireDefault(require("./Dictation"));

var _mapMap = _interopRequireDefault(require("./Utils/mapMap"));

var _observableToPromise = _interopRequireDefault(require("./Utils/observableToPromise"));

var _shallowEquals = _interopRequireDefault(require("./Utils/shallowEquals"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

// Flywheel object
var EMPTY_ARRAY = [];
var DISPATCHERS = {
  markActivity: _botframeworkWebchatCore.markActivity,
  postActivity: _botframeworkWebchatCore.postActivity,
  sendEvent: _botframeworkWebchatCore.sendEvent,
  sendFiles: _botframeworkWebchatCore.sendFiles,
  sendMessage: _botframeworkWebchatCore.sendMessage,
  sendMessageBack: _botframeworkWebchatCore.sendMessageBack,
  sendPostBack: _botframeworkWebchatCore.sendPostBack,
  setDictateInterims: _botframeworkWebchatCore.setDictateInterims,
  setDictateState: _botframeworkWebchatCore.setDictateState,
  setSendBox: _botframeworkWebchatCore.setSendBox,
  setSendTimeout: _botframeworkWebchatCore.setSendTimeout,
  startDictate: _botframeworkWebchatCore.startDictate,
  startSpeakingActivity: _botframeworkWebchatCore.startSpeakingActivity,
  stopDictate: _botframeworkWebchatCore.stopDictate,
  stopSpeakingActivity: _botframeworkWebchatCore.stopSpeakingActivity,
  submitSendBox: _botframeworkWebchatCore.submitSendBox
};

function styleSetToClassNames(styleSet) {
  return (0, _mapMap.default)(styleSet, function (style, key) {
    return key === 'options' ? style : (0, _glamor.css)(style);
  });
}

function createCardActionLogic(_ref) {
  var cardActionMiddleware = _ref.cardActionMiddleware,
      directLine = _ref.directLine,
      dispatch = _ref.dispatch;
  var runMiddleware = (0, _concatMiddleware.default)(cardActionMiddleware, (0, _createCoreMiddleware.default)())({
    dispatch: dispatch
  });
  return {
    onCardAction: function onCardAction(cardAction) {
      return runMiddleware(function (_ref2) {
        var type = _ref2.cardAction.type;
        throw new Error("Web Chat: received unknown card action \"".concat(type, "\""));
      })({
        cardAction: cardAction,
        getSignInUrl: cardAction.type === 'signin' ? function () {
          var value = cardAction.value;

          if (directLine.getSessionId) {
            // TODO: [P3] We should change this one to async/await.
            //       This is the first place in this project to use async.
            //       Thus, we need to add @babel/plugin-transform-runtime and @babel/runtime.
            return (0, _observableToPromise.default)(directLine.getSessionId()).then(function (sessionId) {
              return "".concat(value).concat(encodeURIComponent("&code_challenge=".concat(sessionId)));
            });
          }

          return value;
        } : null
      });
    }
  };
}

function createFocusSendBoxLogic(_ref3) {
  var sendBoxRef = _ref3.sendBoxRef;
  return {
    focusSendBox: function focusSendBox() {
      var _ref4 = sendBoxRef || {},
          current = _ref4.current;

      current && current.focus();
    }
  };
}

function createStyleSetLogic(_ref5) {
  var styleOptions = _ref5.styleOptions,
      styleSet = _ref5.styleSet;
  return {
    styleSet: styleSetToClassNames(styleSet || (0, _createStyleSet.default)(styleOptions))
  };
} // TODO: [P3] Take this deprecation code out when releasing on or after 2019 December 11


function patchPropsForAvatarInitials(_ref6) {
  var botAvatarInitials = _ref6.botAvatarInitials,
      userAvatarInitials = _ref6.userAvatarInitials,
      props = _objectWithoutProperties(_ref6, ["botAvatarInitials", "userAvatarInitials"]);

  // This code will take out "botAvatarInitials" and "userAvatarInitials" from props
  var styleOptions = props.styleOptions;

  if (botAvatarInitials) {
    styleOptions = _objectSpread({}, styleOptions, {
      botAvatarInitials: botAvatarInitials
    });
    console.warn('Web Chat: "botAvatarInitials" is deprecated. Please use "styleOptions.botAvatarInitials" instead. "botAvatarInitials" will be removed on or after December 11 2019 .');
  }

  if (userAvatarInitials) {
    styleOptions = _objectSpread({}, styleOptions, {
      userAvatarInitials: userAvatarInitials
    });
    console.warn('Web Chat: "botAvatarInitials" is deprecated. Please use "styleOptions.botAvatarInitials" instead. "botAvatarInitials" will be removed on or after December 11 2019 .');
  }

  return _objectSpread({}, props, {
    styleOptions: styleOptions
  });
}

function createLogic(props) {
  // This is a heavy function, and it is expected to be only called when there is a need to recreate business logic, e.g.
  // - User ID changed, causing all send* functions to be updated
  // - send
  // TODO: [P4] We should break this into smaller pieces using memoization function, so we don't recreate styleSet if userID is changed
  // TODO: [P3] We should think about if we allow the user to change onSendBoxValueChanged/sendBoxValue, e.g.
  // 1. Turns text into UPPERCASE
  // 2. Filter out profanity
  // TODO: [P4] Revisit all members of context
  props = patchPropsForAvatarInitials(props);
  return _objectSpread({}, props, createCardActionLogic(props), createFocusSendBoxLogic(props), createStyleSetLogic(props));
}

function dispatchSetLanguageFromProps(_ref7) {
  var dispatch = _ref7.dispatch,
      locale = _ref7.locale;
  dispatch((0, _botframeworkWebchatCore.setLanguage)(locale));
}

function dispatchSetSendTimeoutFromProps(_ref8) {
  var dispatch = _ref8.dispatch,
      sendTimeout = _ref8.sendTimeout;
  dispatch((0, _botframeworkWebchatCore.setSendTimeout)(sendTimeout));
}

function dispatchSetSendTypingIndicatorFromProps(_ref9) {
  var dispatch = _ref9.dispatch,
      sendTyping = _ref9.sendTyping,
      sendTypingIndicator = _ref9.sendTypingIndicator;

  if (typeof sendTyping === 'undefined') {
    dispatch((0, _botframeworkWebchatCore.setSendTypingIndicator)(!!sendTypingIndicator));
  } else {
    // TODO: [P3] Take this deprecation code out when releasing on or after January 13 2020
    console.warn('Web Chat: "sendTyping" has been renamed to "sendTypingIndicator". Please use "sendTypingIndicator" instead. This deprecation migration will be removed on or after January 13 2020.');
    dispatch((0, _botframeworkWebchatCore.setSendTypingIndicator)(!!sendTyping));
  }
}

var Composer =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Composer, _React$Component);

  function Composer(props) {
    var _this;

    _classCallCheck(this, Composer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Composer).call(this, props));
    _this.createContextFromProps = (0, _memoizeOne.default)(createLogic, _shallowEquals.default);
    _this.createWebSpeechPonyfill = (0, _memoizeOne.default)(function (webSpeechPonyfillFactory, referenceGrammarID) {
      return webSpeechPonyfillFactory && webSpeechPonyfillFactory({
        referenceGrammarID: referenceGrammarID
      });
    });
    _this.mergeContext = (0, _memoizeOne.default)(function () {
      for (var _len = arguments.length, contexts = new Array(_len), _key = 0; _key < _len; _key++) {
        contexts[_key] = arguments[_key];
      }

      return Object.assign.apply(Object, [{}].concat(contexts));
    }, _shallowEquals.default);
    _this.state = {
      hoistedDispatchers: (0, _mapMap.default)(DISPATCHERS, function (dispatcher) {
        return function () {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return props.dispatch(dispatcher.apply(_assertThisInitialized(_this), args));
        };
      })
    };
    return _this;
  }

  _createClass(Composer, [{
    key: "componentWillMount",
    value: function componentWillMount() {
      var props = this.props;
      var directLine = props.directLine,
          userID = props.userID,
          username = props.username;
      dispatchSetLanguageFromProps(props);
      dispatchSetSendTimeoutFromProps(props);
      dispatchSetSendTypingIndicatorFromProps(props);
      props.dispatch((0, _botframeworkWebchatCore.connect)({
        directLine: directLine,
        userID: userID,
        username: username
      }));
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var props = this.props;
      var directLine = props.directLine,
          locale = props.locale,
          sendTimeout = props.sendTimeout,
          sendTyping = props.sendTyping,
          sendTypingIndicator = props.sendTypingIndicator,
          userID = props.userID,
          username = props.username;

      if (prevProps.locale !== locale) {
        dispatchSetLanguageFromProps(props);
      }

      if (prevProps.sendTimeout !== sendTimeout) {
        dispatchSetSendTimeoutFromProps(props);
      }

      if (!prevProps.sendTypingIndicator !== !sendTypingIndicator || // TODO: [P3] Take this deprecation code out when releasing on or after January 13 2020
      !prevProps.sendTyping !== !sendTyping) {
        dispatchSetSendTypingIndicatorFromProps(props);
      }

      if (prevProps.directLine !== directLine || prevProps.userID !== userID || prevProps.username !== username) {
        // TODO: [P3] disconnect() is an async call (pending -> fulfilled), we need to wait, or change it to reconnect()
        props.dispatch((0, _botframeworkWebchatCore.disconnect)());
        props.dispatch((0, _botframeworkWebchatCore.connect)({
          directLine: directLine,
          userID: userID,
          username: username
        }));
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props = this.props,
          activityRenderer = _this$props.activityRenderer,
          attachmentRenderer = _this$props.attachmentRenderer,
          children = _this$props.children,
          disabled = _this$props.disabled,
          grammars = _this$props.grammars,
          groupTimestamp = _this$props.groupTimestamp,
          referenceGrammarID = _this$props.referenceGrammarID,
          renderMarkdown = _this$props.renderMarkdown,
          scrollToEnd = _this$props.scrollToEnd,
          store = _this$props.store,
          _userID = _this$props.userID,
          _username = _this$props.username,
          webSpeechPonyfillFactory = _this$props.webSpeechPonyfillFactory,
          propsForLogic = _objectWithoutProperties(_this$props, ["activityRenderer", "attachmentRenderer", "children", "disabled", "grammars", "groupTimestamp", "referenceGrammarID", "renderMarkdown", "scrollToEnd", "store", "userID", "username", "webSpeechPonyfillFactory"]),
          state = this.state;

      var contextFromProps = this.createContextFromProps(propsForLogic);
      var context = this.mergeContext(contextFromProps, state.hoistedDispatchers, // TODO: [P4] Should we normalize empties here? Or should we let it thru?
      //       If we let it thru, the code below become simplified and the user can plug in whatever they want for context, via Composer.props
      {
        activityRenderer: activityRenderer,
        attachmentRenderer: attachmentRenderer,
        groupTimestamp: groupTimestamp,
        disabled: disabled,
        grammars: grammars || EMPTY_ARRAY,
        renderMarkdown: renderMarkdown,
        scrollToEnd: scrollToEnd,
        store: store,
        webSpeechPonyfill: this.createWebSpeechPonyfill(webSpeechPonyfillFactory, referenceGrammarID)
      }); // TODO: [P3] Check how many times we do re-render context

      return _react.default.createElement(_Context.default.Provider, {
        value: context
      }, typeof children === 'function' ? children(context) : children, _react.default.createElement(_Dictation.default, null));
    }
  }]);

  return Composer;
}(_react.default.Component);

var ConnectedComposer = (0, _reactRedux.connect)(function (_ref10) {
  var referenceGrammarID = _ref10.referenceGrammarID;
  return {
    referenceGrammarID: referenceGrammarID
  };
})(function (props) {
  return _react.default.createElement(_reactScrollToBottom.Composer, null, _react.default.createElement(_reactScrollToBottom.FunctionContext.Consumer, null, function (_ref11) {
    var scrollToEnd = _ref11.scrollToEnd;
    return _react.default.createElement(Composer, _extends({
      scrollToEnd: scrollToEnd
    }, props));
  }));
}); // We will create a Redux store if it was not passed in

var ConnectedComposerWithStore =
/*#__PURE__*/
function (_React$Component2) {
  _inherits(ConnectedComposerWithStore, _React$Component2);

  function ConnectedComposerWithStore(props) {
    var _this2;

    _classCallCheck(this, ConnectedComposerWithStore);

    _this2 = _possibleConstructorReturn(this, _getPrototypeOf(ConnectedComposerWithStore).call(this, props));
    _this2.createMemoizedStore = (0, _memoizeOne.default)(function () {
      return (0, _botframeworkWebchatCore.createStore)();
    });
    return _this2;
  }

  _createClass(ConnectedComposerWithStore, [{
    key: "render",
    value: function render() {
      var props = this.props;
      return _react.default.createElement(ConnectedComposer, _extends({}, props, {
        store: props.store || this.createMemoizedStore()
      }));
    }
  }]);

  return ConnectedComposerWithStore;
}(_react.default.Component);

var _default = ConnectedComposerWithStore; // TODO: [P3] We should consider moving some props to Redux store
//       Although we use `connectToWebChat` to hide the details of accessor of Redux store,
//       we should clean up the responsibility between Context and Redux store
//       We should decide which data is needed for React but not in other environment such as CLI/VSCode

exports.default = _default;
Composer.defaultProps = {
  activityRenderer: undefined,
  adaptiveCardHostConfig: undefined,
  attachmentRenderer: undefined,
  cardActionMiddleware: undefined,
  children: undefined,
  disabled: false,
  grammars: [],
  groupTimestamp: true,
  locale: window.navigator.language || 'en-US',
  referenceGrammarID: '',
  renderMarkdown: function renderMarkdown(text) {
    return text;
  },
  sendTimeout: 20000,
  sendTyping: undefined,
  sendTypingIndicator: false,
  store: undefined,
  styleOptions: {},
  userID: '',
  username: '',
  webSpeechPonyfillFactory: undefined
};
Composer.propTypes = {
  activityRenderer: _propTypes.default.func,
  adaptiveCardHostConfig: _propTypes.default.any,
  attachmentRenderer: _propTypes.default.func,
  cardActionMiddleware: _propTypes.default.func,
  children: _propTypes.default.any,
  directLine: _propTypes.default.shape({
    activity$: _propTypes.default.shape({
      subscribe: _propTypes.default.func.isRequired
    }).isRequired,
    connectionStatus$: _propTypes.default.shape({
      subscribe: _propTypes.default.func.isRequired
    }).isRequired,
    end: _propTypes.default.func,
    getSessionId: _propTypes.default.func.isRequired,
    postActivity: _propTypes.default.func.isRequired,
    referenceGrammarID: _propTypes.default.string,
    token: _propTypes.default.string
  }).isRequired,
  disabled: _propTypes.default.bool,
  dispatch: _propTypes.default.func.isRequired,
  grammars: _propTypes.default.arrayOf(_propTypes.default.string),
  groupTimestamp: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.number]),
  locale: _propTypes.default.string,
  referenceGrammarID: _propTypes.default.string,
  renderMarkdown: _propTypes.default.func,
  scrollToEnd: _propTypes.default.func.isRequired,
  sendTimeout: _propTypes.default.number,
  sendTyping: _propTypes.default.bool,
  sendTypingIndicator: _propTypes.default.bool,
  store: _propTypes.default.any,
  styleOptions: _propTypes.default.any,
  userID: _propTypes.default.string,
  username: _propTypes.default.string,
  webSpeechPonyfillFactory: _propTypes.default.func
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9Db21wb3Nlci5qcyJdLCJuYW1lcyI6WyJFTVBUWV9BUlJBWSIsIkRJU1BBVENIRVJTIiwibWFya0FjdGl2aXR5IiwicG9zdEFjdGl2aXR5Iiwic2VuZEV2ZW50Iiwic2VuZEZpbGVzIiwic2VuZE1lc3NhZ2UiLCJzZW5kTWVzc2FnZUJhY2siLCJzZW5kUG9zdEJhY2siLCJzZXREaWN0YXRlSW50ZXJpbXMiLCJzZXREaWN0YXRlU3RhdGUiLCJzZXRTZW5kQm94Iiwic2V0U2VuZFRpbWVvdXQiLCJzdGFydERpY3RhdGUiLCJzdGFydFNwZWFraW5nQWN0aXZpdHkiLCJzdG9wRGljdGF0ZSIsInN0b3BTcGVha2luZ0FjdGl2aXR5Iiwic3VibWl0U2VuZEJveCIsInN0eWxlU2V0VG9DbGFzc05hbWVzIiwic3R5bGVTZXQiLCJzdHlsZSIsImtleSIsImNyZWF0ZUNhcmRBY3Rpb25Mb2dpYyIsImNhcmRBY3Rpb25NaWRkbGV3YXJlIiwiZGlyZWN0TGluZSIsImRpc3BhdGNoIiwicnVuTWlkZGxld2FyZSIsIm9uQ2FyZEFjdGlvbiIsImNhcmRBY3Rpb24iLCJ0eXBlIiwiRXJyb3IiLCJnZXRTaWduSW5VcmwiLCJ2YWx1ZSIsImdldFNlc3Npb25JZCIsInRoZW4iLCJzZXNzaW9uSWQiLCJlbmNvZGVVUklDb21wb25lbnQiLCJjcmVhdGVGb2N1c1NlbmRCb3hMb2dpYyIsInNlbmRCb3hSZWYiLCJmb2N1c1NlbmRCb3giLCJjdXJyZW50IiwiZm9jdXMiLCJjcmVhdGVTdHlsZVNldExvZ2ljIiwic3R5bGVPcHRpb25zIiwicGF0Y2hQcm9wc0ZvckF2YXRhckluaXRpYWxzIiwiYm90QXZhdGFySW5pdGlhbHMiLCJ1c2VyQXZhdGFySW5pdGlhbHMiLCJwcm9wcyIsImNvbnNvbGUiLCJ3YXJuIiwiY3JlYXRlTG9naWMiLCJkaXNwYXRjaFNldExhbmd1YWdlRnJvbVByb3BzIiwibG9jYWxlIiwiZGlzcGF0Y2hTZXRTZW5kVGltZW91dEZyb21Qcm9wcyIsInNlbmRUaW1lb3V0IiwiZGlzcGF0Y2hTZXRTZW5kVHlwaW5nSW5kaWNhdG9yRnJvbVByb3BzIiwic2VuZFR5cGluZyIsInNlbmRUeXBpbmdJbmRpY2F0b3IiLCJDb21wb3NlciIsImNyZWF0ZUNvbnRleHRGcm9tUHJvcHMiLCJzaGFsbG93RXF1YWxzIiwiY3JlYXRlV2ViU3BlZWNoUG9ueWZpbGwiLCJ3ZWJTcGVlY2hQb255ZmlsbEZhY3RvcnkiLCJyZWZlcmVuY2VHcmFtbWFySUQiLCJtZXJnZUNvbnRleHQiLCJjb250ZXh0cyIsIk9iamVjdCIsImFzc2lnbiIsInN0YXRlIiwiaG9pc3RlZERpc3BhdGNoZXJzIiwiZGlzcGF0Y2hlciIsImFyZ3MiLCJhcHBseSIsInVzZXJJRCIsInVzZXJuYW1lIiwicHJldlByb3BzIiwiYWN0aXZpdHlSZW5kZXJlciIsImF0dGFjaG1lbnRSZW5kZXJlciIsImNoaWxkcmVuIiwiZGlzYWJsZWQiLCJncmFtbWFycyIsImdyb3VwVGltZXN0YW1wIiwicmVuZGVyTWFya2Rvd24iLCJzY3JvbGxUb0VuZCIsInN0b3JlIiwiX3VzZXJJRCIsIl91c2VybmFtZSIsInByb3BzRm9yTG9naWMiLCJjb250ZXh0RnJvbVByb3BzIiwiY29udGV4dCIsIndlYlNwZWVjaFBvbnlmaWxsIiwiUmVhY3QiLCJDb21wb25lbnQiLCJDb25uZWN0ZWRDb21wb3NlciIsIkNvbm5lY3RlZENvbXBvc2VyV2l0aFN0b3JlIiwiY3JlYXRlTWVtb2l6ZWRTdG9yZSIsImRlZmF1bHRQcm9wcyIsInVuZGVmaW5lZCIsImFkYXB0aXZlQ2FyZEhvc3RDb25maWciLCJ3aW5kb3ciLCJuYXZpZ2F0b3IiLCJsYW5ndWFnZSIsInRleHQiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJmdW5jIiwiYW55Iiwic2hhcGUiLCJhY3Rpdml0eSQiLCJzdWJzY3JpYmUiLCJpc1JlcXVpcmVkIiwiY29ubmVjdGlvblN0YXR1cyQiLCJlbmQiLCJzdHJpbmciLCJ0b2tlbiIsImJvb2wiLCJhcnJheU9mIiwib25lT2ZUeXBlIiwibnVt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cEIsQ0F0Qkc7QUF1Qm5CbEUsRUFBQUEsTUFBTSxFQUFFb0QsbUJBQVVTLE1BdkJDO0FBd0JuQmxELEVBQUFBLGtCQUFrQixFQUFFeUMsbUJBQVVTLE1BeEJYO0FBeUJuQi9CLEVBQUFBLGNBQWMsRUFBRXNCLG1CQUFVQyxJQXpCUDtBQTBCbkJ0QixFQUFBQSxXQUFXLEVBQUVxQixtQkFBVUMsSUFBVixDQUFlSyxVQTFCVDtBQTJCbkJ4RCxFQUFBQSxXQUFXLEVBQUVrRCxtQkFBVWMsTUEzQko7QUE0Qm5COUQsRUFBQUEsVUFBVSxFQUFFZ0QsbUJBQVVXLElBNUJIO0FBNkJuQjFELEVBQUFBLG1CQUFtQixFQUFFK0MsbUJBQVVXLElBN0JaO0FBOEJuQi9CLEVBQUFBLEtBQUssRUFBRW9CLG1CQUFVRSxHQTlCRTtBQStCbkIvRCxFQUFBQSxZQUFZLEVBQUU2RCxtQkFBVUUsR0EvQkw7QUFnQ25CakMsRUFBQUEsTUFBTSxFQUFFK0IsbUJBQVVTLE1BaENDO0FBaUNuQnZDLEVBQUFBLFFBQVEsRUFBRThCLG1CQUFVUyxNQWpDRDtBQWtDbkJuRCxFQUFBQSx3QkFBd0IsRUFBRTBDLG1CQUFVQztBQWxDakIsQ0FBckIiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb3NlciBhcyBTY3JvbGxUb0JvdHRvbUNvbXBvc2VyLFxuICBGdW5jdGlvbkNvbnRleHQgYXMgU2Nyb2xsVG9Cb3R0b21GdW5jdGlvbkNvbnRleHRcbn0gZnJvbSAncmVhY3Qtc2Nyb2xsLXRvLWJvdHRvbSc7XG5cbmltcG9ydCB7IGNvbm5lY3QgfSBmcm9tICdyZWFjdC1yZWR1eCc7XG5pbXBvcnQgeyBjc3MgfSBmcm9tICdnbGFtb3InO1xuaW1wb3J0IG1lbW9pemUgZnJvbSAnbWVtb2l6ZS1vbmUnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCB7XG4gIGNvbm5lY3QgYXMgY3JlYXRlQ29ubmVjdEFjdGlvbixcbiAgY3JlYXRlU3RvcmUsXG4gIGRpc2Nvbm5lY3QsXG4gIG1hcmtBY3Rpdml0eSxcbiAgcG9zdEFjdGl2aXR5LFxuICBzZW5kRXZlbnQsXG4gIHNlbmRGaWxlcyxcbiAgc2VuZE1lc3NhZ2UsXG4gIHNlbmRNZXNzYWdlQmFjayxcbiAgc2VuZFBvc3RCYWNrLFxuICBzZXREaWN0YXRlSW50ZXJpbXMsXG4gIHNldERpY3RhdGVTdGF0ZSxcbiAgc2V0TGFuZ3VhZ2UsXG4gIHNldFNlbmRCb3gsXG4gIHNldFNlbmRUaW1lb3V0LFxuICBzZXRTZW5kVHlwaW5nSW5kaWNhdG9yLFxuICBzdGFydERpY3RhdGUsXG4gIHN0YXJ0U3BlYWtpbmdBY3Rpdml0eSxcbiAgc3RvcERpY3RhdGUsXG4gIHN0b3BTcGVha2luZ0FjdGl2aXR5LFxuICBzdWJtaXRTZW5kQm94XG59IGZyb20gJ2JvdGZyYW1ld29yay13ZWJjaGF0LWNvcmUnO1xuXG5pbXBvcnQgY29uY2F0TWlkZGxld2FyZSBmcm9tICcuL01pZGRsZXdhcmUvY29uY2F0TWlkZGxld2FyZSc7XG5pbXBvcnQgQ29udGV4dCBmcm9tICcuL0NvbnRleHQnO1xuaW1wb3J0IGNyZWF0ZUNvcmVDYXJkQWN0aW9uTWlkZGxld2FyZSBmcm9tICcuL01pZGRsZXdhcmUvQ2FyZEFjdGlvbi9jcmVhdGVDb3JlTWlkZGxld2FyZSc7XG5pbXBvcnQgY3JlYXRlU3R5bGVTZXQgZnJvbSAnLi9TdHlsZXMvY3JlYXRlU3R5bGVTZXQnO1xuaW1wb3J0IERpY3RhdGlvbiBmcm9tICcuL0RpY3RhdGlvbic7XG5pbXBvcnQgbWFwTWFwIGZyb20gJy4vVXRpbHMvbWFwTWFwJztcbmltcG9ydCBvYnNlcnZhYmxlVG9Qcm9taXNlIGZyb20gJy4vVXRpbHMvb2JzZXJ2YWJsZVRvUHJvbWlzZSc7XG5pbXBvcnQgc2hhbGxvd0VxdWFscyBmcm9tICcuL1V0aWxzL3NoYWxsb3dFcXVhbHMnO1xuXG4vLyBGbHl3aGVlbCBvYmplY3RcbmNvbnN0IEVNUFRZX0FSUkFZID0gW107XG5cbmNvbnN0IERJU1BBVENIRVJTID0ge1xuICBtYXJrQWN0aXZpdHksXG4gIHBvc3RBY3Rpdml0eSxcbiAgc2VuZEV2ZW50LFxuICBzZW5kRmlsZXMsXG4gIHNlbmRNZXNzYWdlLFxuICBzZW5kTWVzc2FnZUJhY2ssXG4gIHNlbmRQb3N0QmFjayxcbiAgc2V0RGljdGF0ZUludGVyaW1zLFxuICBzZXREaWN0YXRlU3RhdGUsXG4gIHNldFNlbmRCb3gsXG4gIHNldFNlbmRUaW1lb3V0LFxuICBzdGFydERpY3RhdGUsXG4gIHN0YXJ0U3BlYWtpbmdBY3Rpdml0eSxcbiAgc3RvcERpY3RhdGUsXG4gIHN0b3BTcGVha2luZ0FjdGl2aXR5LFxuICBzdWJtaXRTZW5kQm94XG59O1xuXG5mdW5jdGlvbiBzdHlsZVNldFRvQ2xhc3NOYW1lcyhzdHlsZVNldCkge1xuICByZXR1cm4gbWFwTWFwKHN0eWxlU2V0LCAoc3R5bGUsIGtleSkgPT4gKGtleSA9PT0gJ29wdGlvbnMnID8gc3R5bGUgOiBjc3Moc3R5bGUpKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhcmRBY3Rpb25Mb2dpYyh7IGNhcmRBY3Rpb25NaWRkbGV3YXJlLCBkaXJlY3RMaW5lLCBkaXNwYXRjaCB9KSB7XG4gIGNvbnN0IHJ1bk1pZGRsZXdhcmUgPSBjb25jYXRNaWRkbGV3YXJlKGNhcmRBY3Rpb25NaWRkbGV3YXJlLCBjcmVhdGVDb3JlQ2FyZEFjdGlvbk1pZGRsZXdhcmUoKSkoeyBkaXNwYXRjaCB9KTtcblxuICByZXR1cm4ge1xuICAgIG9uQ2FyZEFjdGlvbjogY2FyZEFjdGlvbiA9PlxuICAgICAgcnVuTWlkZGxld2FyZSgoeyBjYXJkQWN0aW9uOiB7IHR5cGUgfSB9KSA9PiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV2ViIENoYXQ6IHJlY2VpdmVkIHVua25vd24gY2FyZCBhY3Rpb24gXCIke3R5cGV9XCJgKTtcbiAgICAgIH0pKHtcbiAgICAgICAgY2FyZEFjdGlvbixcbiAgICAgICAgZ2V0U2lnbkluVXJsOlxuICAgICAgICAgIGNhcmRBY3Rpb24udHlwZSA9PT0gJ3NpZ25pbidcbiAgICAgICAgICAgID8gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IGNhcmRBY3Rpb247XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlyZWN0TGluZS5nZXRTZXNzaW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IFtQM10gV2Ugc2hvdWxkIGNoYW5nZSB0aGlzIG9uZSB0byBhc3luYy9hd2FpdC5cbiAgICAgICAgICAgICAgICAgIC8vICAgICAgIFRoaXMgaXMgdGhlIGZpcnN0IHBsYWNlIGluIHRoaXMgcHJvamVjdCB0byB1c2UgYXN5bmMuXG4gICAgICAgICAgICAgICAgICAvLyAgICAgICBUaHVzLCB3ZSBuZWVkIHRvIGFkZCBAYmFiZWwvcGx1Z2luLXRyYW5zZm9ybS1ydW50aW1lIGFuZCBAYmFiZWwvcnVudGltZS5cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIG9ic2VydmFibGVUb1Byb21pc2UoZGlyZWN0TGluZS5nZXRTZXNzaW9uSWQoKSkudGhlbihcbiAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbklkID0+IGAke3ZhbHVlfSR7ZW5jb2RlVVJJQ29tcG9uZW50KGAmY29kZV9jaGFsbGVuZ2U9JHtzZXNzaW9uSWR9YCl9YFxuICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIDogbnVsbFxuICAgICAgfSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRm9jdXNTZW5kQm94TG9naWMoeyBzZW5kQm94UmVmIH0pIHtcbiAgcmV0dXJuIHtcbiAgICBmb2N1c1NlbmRCb3g6ICgpID0+IHtcbiAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gc2VuZEJveFJlZiB8fCB7fTtcblxuICAgICAgY3VycmVudCAmJiBjdXJyZW50LmZvY3VzKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTdHlsZVNldExvZ2ljKHsgc3R5bGVPcHRpb25zLCBzdHlsZVNldCB9KSB7XG4gIHJldHVybiB7XG4gICAgc3R5bGVTZXQ6IHN0eWxlU2V0VG9DbGFzc05hbWVzKHN0eWxlU2V0IHx8IGNyZWF0ZVN0eWxlU2V0KHN0eWxlT3B0aW9ucykpXG4gIH07XG59XG5cbi8vIFRPRE86IFtQM10gVGFrZSB0aGlzIGRlcHJlY2F0aW9uIGNvZGUgb3V0IHdoZW4gcmVsZWFzaW5nIG9uIG9yIGFmdGVyIDIwMTkgRGVjZW1iZXIgMTFcbmZ1bmN0aW9uIHBhdGNoUHJvcHNGb3JBdmF0YXJJbml0aWFscyh7IGJvdEF2YXRhckluaXRpYWxzLCB1c2VyQXZhdGFySW5pdGlhbHMsIC4uLnByb3BzIH0pIHtcbiAgLy8gVGhpcyBjb2RlIHdpbGwgdGFrZSBvdXQgXCJib3RBdmF0YXJJbml0aWFsc1wiIGFuZCBcInVzZXJBdmF0YXJJbml0aWFsc1wiIGZyb20gcHJvcHNcblxuICBsZXQgeyBzdHlsZU9wdGlvbnMgfSA9IHByb3BzO1xuXG4gIGlmIChib3RBdmF0YXJJbml0aWFscykge1xuICAgIHN0eWxlT3B0aW9ucyA9IHsgLi4uc3R5bGVPcHRpb25zLCBib3RBdmF0YXJJbml0aWFscyB9O1xuXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dlYiBDaGF0OiBcImJvdEF2YXRhckluaXRpYWxzXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcInN0eWxlT3B0aW9ucy5ib3RBdmF0YXJJbml0aWFsc1wiIGluc3RlYWQuIFwiYm90QXZhdGFySW5pdGlhbHNcIiB3aWxsIGJlIHJlbW92ZWQgb24gb3IgYWZ0ZXIgRGVjZW1iZXIgMTEgMjAxOSAuJ1xuICAgICk7XG4gIH1cblxuICBpZiAodXNlckF2YXRhckluaXRpYWxzKSB7XG4gICAgc3R5bGVPcHRpb25zID0geyAuLi5zdHlsZU9wdGlvbnMsIHVzZXJBdmF0YXJJbml0aWFscyB9O1xuXG4gICAgY29uc29sZS53YXJuKFxuICAgICAgJ1dlYiBDaGF0OiBcImJvdEF2YXRhckluaXRpYWxzXCIgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBcInN0eWxlT3B0aW9ucy5ib3RBdmF0YXJJbml0aWFsc1wiIGluc3RlYWQuIFwiYm90QXZhdGFySW5pdGlhbHNcIiB3aWxsIGJlIHJlbW92ZWQgb24gb3IgYWZ0ZXIgRGVjZW1iZXIgMTEgMjAxOSAuJ1xuICAgICk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC4uLnByb3BzLFxuICAgIHN0eWxlT3B0aW9uc1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVMb2dpYyhwcm9wcykge1xuICAvLyBUaGlzIGlzIGEgaGVhdnkgZnVuY3Rpb24sIGFuZCBpdCBpcyBleHBlY3RlZCB0byBiZSBvbmx5IGNhbGxlZCB3aGVuIHRoZXJlIGlzIGEgbmVlZCB0byByZWNyZWF0ZSBidXNpbmVzcyBsb2dpYywgZS5nLlxuICAvLyAtIFVzZXIgSUQgY2hhbmdlZCwgY2F1c2luZyBhbGwgc2VuZCogZnVuY3Rpb25zIHRvIGJlIHVwZGF0ZWRcbiAgLy8gLSBzZW5kXG5cbiAgLy8gVE9ETzogW1A0XSBXZSBzaG91bGQgYnJlYWsgdGhpcyBpbnRvIHNtYWxsZXIgcGllY2VzIHVzaW5nIG1lbW9pemF0aW9uIGZ1bmN0aW9uLCBzbyB3ZSBkb24ndCByZWNyZWF0ZSBzdHlsZVNldCBpZiB1c2VySUQgaXMgY2hhbmdlZFxuXG4gIC8vIFRPRE86IFtQM10gV2Ugc2hvdWxkIHRoaW5rIGFib3V0IGlmIHdlIGFsbG93IHRoZSB1c2VyIHRvIGNoYW5nZSBvblNlbmRCb3hWYWx1ZUNoYW5nZWQvc2VuZEJveFZhbHVlLCBlLmcuXG4gIC8vIDEuIFR1cm5zIHRleHQgaW50byBVUFBFUkNBU0VcbiAgLy8gMi4gRmlsdGVyIG91dCBwcm9mYW5pdHlcblxuICAvLyBUT0RPOiBbUDRdIFJldmlzaXQgYWxsIG1lbWJlcnMgb2YgY29udGV4dFxuICBwcm9wcyA9IHBhdGNoUHJvcHNGb3JBdmF0YXJJbml0aWFscyhwcm9wcyk7XG5cbiAgcmV0dXJuIHtcbiAgICAuLi5wcm9wcyxcbiAgICAuLi5jcmVhdGVDYXJkQWN0aW9uTG9naWMocHJvcHMpLFxuICAgIC4uLmNyZWF0ZUZvY3VzU2VuZEJveExvZ2ljKHByb3BzKSxcbiAgICAuLi5jcmVhdGVTdHlsZVNldExvZ2ljKHByb3BzKVxuICB9O1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFNldExhbmd1YWdlRnJvbVByb3BzKHsgZGlzcGF0Y2gsIGxvY2FsZSB9KSB7XG4gIGRpc3BhdGNoKHNldExhbmd1YWdlKGxvY2FsZSkpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFNldFNlbmRUaW1lb3V0RnJvbVByb3BzKHsgZGlzcGF0Y2gsIHNlbmRUaW1lb3V0IH0pIHtcbiAgZGlzcGF0Y2goc2V0U2VuZFRpbWVvdXQoc2VuZFRpbWVvdXQpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hTZXRTZW5kVHlwaW5nSW5kaWNhdG9yRnJvbVByb3BzKHsgZGlzcGF0Y2gsIHNlbmRUeXBpbmcsIHNlbmRUeXBpbmdJbmRpY2F0b3IgfSkge1xuICBpZiAodHlwZW9mIHNlbmRUeXBpbmcgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgZGlzcGF0Y2goc2V0U2VuZFR5cGluZ0luZGljYXRvcighIXNlbmRUeXBpbmdJbmRpY2F0b3IpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPOiBbUDNdIFRha2UgdGhpcyBkZXByZWNhdGlvbiBjb2RlIG91dCB3aGVuIHJlbGVhc2luZyBvbiBvciBhZnRlciBKYW51YXJ5IDEzIDIwMjBcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnV2ViIENoYXQ6IFwic2VuZFR5cGluZ1wiIGhhcyBiZWVuIHJlbmFtZWQgdG8gXCJzZW5kVHlwaW5nSW5kaWNhdG9yXCIuIFBsZWFzZSB1c2UgXCJzZW5kVHlwaW5nSW5kaWNhdG9yXCIgaW5zdGVhZC4gVGhpcyBkZXByZWNhdGlvbiBtaWdyYXRpb24gd2lsbCBiZSByZW1vdmVkIG9uIG9yIGFmdGVyIEphbnVhcnkgMTMgMjAyMC4nXG4gICAgKTtcbiAgICBkaXNwYXRjaChzZXRTZW5kVHlwaW5nSW5kaWNhdG9yKCEhc2VuZFR5cGluZykpO1xuICB9XG59XG5cbmNsYXNzIENvbXBvc2VyIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLmNyZWF0ZUNvbnRleHRGcm9tUHJvcHMgPSBtZW1vaXplKGNyZWF0ZUxvZ2ljLCBzaGFsbG93RXF1YWxzKTtcblxuICAgIHRoaXMuY3JlYXRlV2ViU3BlZWNoUG9ueWZpbGwgPSBtZW1vaXplKFxuICAgICAgKHdlYlNwZWVjaFBvbnlmaWxsRmFjdG9yeSwgcmVmZXJlbmNlR3JhbW1hcklEKSA9PlxuICAgICAgICB3ZWJTcGVlY2hQb255ZmlsbEZhY3RvcnkgJiYgd2ViU3BlZWNoUG9ueWZpbGxGYWN0b3J5KHsgcmVmZXJlbmNlR3JhbW1hcklEIH0pXG4gICAgKTtcblxuICAgIHRoaXMubWVyZ2VDb250ZXh0ID0gbWVtb2l6ZSgoLi4uY29udGV4dHMpID0+IE9iamVjdC5hc3NpZ24oe30sIC4uLmNvbnRleHRzKSwgc2hhbGxvd0VxdWFscyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaG9pc3RlZERpc3BhdGNoZXJzOiBtYXBNYXAoRElTUEFUQ0hFUlMsIGRpc3BhdGNoZXIgPT4gKC4uLmFyZ3MpID0+IHByb3BzLmRpc3BhdGNoKGRpc3BhdGNoZXIuYXBwbHkodGhpcywgYXJncykpKVxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcbiAgICBjb25zdCB7IGRpcmVjdExpbmUsIHVzZXJJRCwgdXNlcm5hbWUgfSA9IHByb3BzO1xuXG4gICAgZGlzcGF0Y2hTZXRMYW5ndWFnZUZyb21Qcm9wcyhwcm9wcyk7XG4gICAgZGlzcGF0Y2hTZXRTZW5kVGltZW91dEZyb21Qcm9wcyhwcm9wcyk7XG4gICAgZGlzcGF0Y2hTZXRTZW5kVHlwaW5nSW5kaWNhdG9yRnJvbVByb3BzKHByb3BzKTtcblxuICAgIHByb3BzLmRpc3BhdGNoKGNyZWF0ZUNvbm5lY3RBY3Rpb24oeyBkaXJlY3RMaW5lLCB1c2VySUQsIHVzZXJuYW1lIH0pKTtcbiAgfVxuXG4gIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSB0aGlzO1xuICAgIGNvbnN0IHsgZGlyZWN0TGluZSwgbG9jYWxlLCBzZW5kVGltZW91dCwgc2VuZFR5cGluZywgc2VuZFR5cGluZ0luZGljYXRvciwgdXNlcklELCB1c2VybmFtZSB9ID0gcHJvcHM7XG5cbiAgICBpZiAocHJldlByb3BzLmxvY2FsZSAhPT0gbG9jYWxlKSB7XG4gICAgICBkaXNwYXRjaFNldExhbmd1YWdlRnJvbVByb3BzKHByb3BzKTtcbiAgICB9XG5cbiAgICBpZiAocHJldlByb3BzLnNlbmRUaW1lb3V0ICE9PSBzZW5kVGltZW91dCkge1xuICAgICAgZGlzcGF0Y2hTZXRTZW5kVGltZW91dEZyb21Qcm9wcyhwcm9wcyk7XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgIXByZXZQcm9wcy5zZW5kVHlwaW5nSW5kaWNhdG9yICE9PSAhc2VuZFR5cGluZ0luZGljYXRvciB8fFxuICAgICAgLy8gVE9ETzogW1AzXSBUYWtlIHRoaXMgZGVwcmVjYXRpb24gY29kZSBvdXQgd2hlbiByZWxlYXNpbmcgb24gb3IgYWZ0ZXIgSmFudWFyeSAxMyAyMDIwXG4gICAgICAhcHJldlByb3BzLnNlbmRUeXBpbmcgIT09ICFzZW5kVHlwaW5nXG4gICAgKSB7XG4gICAgICBkaXNwYXRjaFNldFNlbmRUeXBpbmdJbmRpY2F0b3JGcm9tUHJvcHMocHJvcHMpO1xuICAgIH1cblxuICAgIGlmIChwcmV2UHJvcHMuZGlyZWN0TGluZSAhPT0gZGlyZWN0TGluZSB8fCBwcmV2UHJvcHMudXNlcklEICE9PSB1c2VySUQgfHwgcHJldlByb3BzLnVzZXJuYW1lICE9PSB1c2VybmFtZSkge1xuICAgICAgLy8gVE9ETzogW1AzXSBkaXNjb25uZWN0KCkgaXMgYW4gYXN5bmMgY2FsbCAocGVuZGluZyAtPiBmdWxmaWxsZWQpLCB3ZSBuZWVkIHRvIHdhaXQsIG9yIGNoYW5nZSBpdCB0byByZWNvbm5lY3QoKVxuICAgICAgcHJvcHMuZGlzcGF0Y2goZGlzY29ubmVjdCgpKTtcbiAgICAgIHByb3BzLmRpc3BhdGNoKGNyZWF0ZUNvbm5lY3RBY3Rpb24oeyBkaXJlY3RMaW5lLCB1c2VySUQsIHVzZXJuYW1lIH0pKTtcbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHJvcHM6IHtcbiAgICAgICAgYWN0aXZpdHlSZW5kZXJlcixcbiAgICAgICAgYXR0YWNobWVudFJlbmRlcmVyLFxuICAgICAgICBjaGlsZHJlbixcblxuICAgICAgICAvLyBUT0RPOiBbUDJdIEFkZCBkaXNhYmxlIGludGVyYWN0aXZpdHlcbiAgICAgICAgZGlzYWJsZWQsXG5cbiAgICAgICAgZ3JhbW1hcnMsXG4gICAgICAgIGdyb3VwVGltZXN0YW1wLFxuICAgICAgICByZWZlcmVuY2VHcmFtbWFySUQsXG4gICAgICAgIHJlbmRlck1hcmtkb3duLFxuICAgICAgICBzY3JvbGxUb0VuZCxcbiAgICAgICAgc3RvcmUsXG4gICAgICAgIHVzZXJJRDogX3VzZXJJRCwgLy8gSWdub3JpbmcgZXNsaW50IG5vLXVudXNlZC12YXJzOiB3ZSBqdXN0IHdhbnQgdG8gcmVtb3ZlIHVzZXJJRCBhbmQgdXNlcm5hbWUgZnJvbSBwcm9wc0ZvckxvZ2ljXG4gICAgICAgIHVzZXJuYW1lOiBfdXNlcm5hbWUsIC8vIElnbm9yaW5nIGVzbGludCBuby11bnVzZWQtdmFyczogd2UganVzdCB3YW50IHRvIHJlbW92ZSB1c2VySUQgYW5kIHVzZXJuYW1lIGZyb20gcHJvcHNGb3JMb2dpY1xuICAgICAgICB3ZWJTcGVlY2hQb255ZmlsbEZhY3RvcnksXG4gICAgICAgIC4uLnByb3BzRm9yTG9naWNcbiAgICAgIH0sXG4gICAgICBzdGF0ZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgY29uc3QgY29udGV4dEZyb21Qcm9wcyA9IHRoaXMuY3JlYXRlQ29udGV4dEZyb21Qcm9wcyhwcm9wc0ZvckxvZ2ljKTtcblxuICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLm1lcmdlQ29udGV4dChcbiAgICAgIGNvbnRleHRGcm9tUHJvcHMsXG4gICAgICBzdGF0ZS5ob2lzdGVkRGlzcGF0Y2hlcnMsXG5cbiAgICAgIC8vIFRPRE86IFtQNF0gU2hvdWxkIHdlIG5vcm1hbGl6ZSBlbXB0aWVzIGhlcmU/IE9yIHNob3VsZCB3ZSBsZXQgaXQgdGhydT9cbiAgICAgIC8vICAgICAgIElmIHdlIGxldCBpdCB0aHJ1LCB0aGUgY29kZSBiZWxvdyBiZWNvbWUgc2ltcGxpZmllZCBhbmQgdGhlIHVzZXIgY2FuIHBsdWcgaW4gd2hhdGV2ZXIgdGhleSB3YW50IGZvciBjb250ZXh0LCB2aWEgQ29tcG9zZXIucHJvcHNcbiAgICAgIHtcbiAgICAgICAgYWN0aXZpdHlSZW5kZXJlcixcbiAgICAgICAgYXR0YWNobWVudFJlbmRlcmVyLFxuICAgICAgICBncm91cFRpbWVzdGFtcCxcbiAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgIGdyYW1tYXJzOiBncmFtbWFycyB8fCBFTVBUWV9BUlJBWSxcbiAgICAgICAgcmVuZGVyTWFya2Rvd24sXG4gICAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgICBzdG9yZSxcbiAgICAgICAgd2ViU3BlZWNoUG9ueWZpbGw6IHRoaXMuY3JlYXRlV2ViU3BlZWNoUG9ueWZpbGwod2ViU3BlZWNoUG9ueWZpbGxGYWN0b3J5LCByZWZlcmVuY2VHcmFtbWFySUQpXG4gICAgICB9XG4gICAgKTtcblxuICAgIC8vIFRPRE86IFtQM10gQ2hlY2sgaG93IG1hbnkgdGltZXMgd2UgZG8gcmUtcmVuZGVyIGNvbnRleHRcblxuICAgIHJldHVybiAoXG4gICAgICA8Q29udGV4dC5Qcm92aWRlciB2YWx1ZT17Y29udGV4dH0+XG4gICAgICAgIHt0eXBlb2YgY2hpbGRyZW4gPT09ICdmdW5jdGlvbicgPyBjaGlsZHJlbihjb250ZXh0KSA6IGNoaWxkcmVufVxuICAgICAgICA8RGljdGF0aW9uIC8+XG4gICAgICA8L0NvbnRleHQuUHJvdmlkZXI+XG4gICAgKTtcbiAgfVxufVxuXG5jb25zdCBDb25uZWN0ZWRDb21wb3NlciA9IGNvbm5lY3QoKHsgcmVmZXJlbmNlR3JhbW1hcklEIH0pID0+ICh7IHJlZmVyZW5jZUdyYW1tYXJJRCB9KSkocHJvcHMgPT4gKFxuICA8U2Nyb2xsVG9Cb3R0b21Db21wb3Nlcj5cbiAgICA8U2Nyb2xsVG9Cb3R0b21GdW5jdGlvbkNvbnRleHQuQ29uc3VtZXI+XG4gICAgICB7KHsgc2Nyb2xsVG9FbmQgfSkgPT4gPENvbXBvc2VyIHNjcm9sbFRvRW5kPXtzY3JvbGxUb0VuZH0gey4uLnByb3BzfSAvPn1cbiAgICA8L1Njcm9sbFRvQm90dG9tRnVuY3Rpb25Db250ZXh0LkNvbnN1bWVyPlxuICA8L1Njcm9sbFRvQm90dG9tQ29tcG9zZXI+XG4pKTtcblxuLy8gV2Ugd2lsbCBjcmVhdGUgYSBSZWR1eCBzdG9yZSBpZiBpdCB3YXMgbm90IHBhc3NlZCBpblxuY2xhc3MgQ29ubmVjdGVkQ29tcG9zZXJXaXRoU3RvcmUgZXh0ZW5kcyBSZWFjdC5Db21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKTtcblxuICAgIHRoaXMuY3JlYXRlTWVtb2l6ZWRTdG9yZSA9IG1lbW9pemUoKCkgPT4gY3JlYXRlU3RvcmUoKSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBwcm9wcyB9ID0gdGhpcztcblxuICAgIHJldHVybiA8Q29ubmVjdGVkQ29tcG9zZXIgey4uLnByb3BzfSBzdG9yZT17cHJvcHMuc3RvcmUgfHwgdGhpcy5jcmVhdGVNZW1vaXplZFN0b3JlKCl9IC8+O1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENvbm5lY3RlZENvbXBvc2VyV2l0aFN0b3JlO1xuXG4vLyBUT0RPOiBbUDNdIFdlIHNob3VsZCBjb25zaWRlciBtb3Zpbmcgc29tZSBwcm9wcyB0byBSZWR1eCBzdG9yZVxuLy8gICAgICAgQWx0aG91Z2ggd2UgdXNlIGBjb25uZWN0VG9XZWJDaGF0YCB0byBoaWRlIHRoZSBkZXRhaWxzIG9mIGFjY2Vzc29yIG9mIFJlZHV4IHN0b3JlLFxuLy8gICAgICAgd2Ugc2hvdWxkIGNsZWFuIHVwIHRoZSByZXNwb25zaWJpbGl0eSBiZXR3ZWVuIENvbnRleHQgYW5kIFJlZHV4IHN0b3JlXG4vLyAgICAgICBXZSBzaG91bGQgZGVjaWRlIHdoaWNoIGRhdGEgaXMgbmVlZGVkIGZvciBSZWFjdCBidXQgbm90IGluIG90aGVyIGVudmlyb25tZW50IHN1Y2ggYXMgQ0xJL1ZTQ29kZVxuXG5Db21wb3Nlci5kZWZhdWx0UHJvcHMgPSB7XG4gIGFjdGl2aXR5UmVuZGVyZXI6IHVuZGVmaW5lZCxcbiAgYWRhcHRpdmVDYXJkSG9zdENvbmZpZzogdW5kZWZpbmVkLFxuICBhdHRhY2htZW50UmVuZGVyZXI6IHVuZGVmaW5lZCxcbiAgY2FyZEFjdGlvbk1pZGRsZXdhcmU6IHVuZGVmaW5lZCxcbiAgY2hpbGRyZW46IHVuZGVmaW5lZCxcbiAgZGlzYWJsZWQ6IGZhbHNlLFxuICBncmFtbWFyczogW10sXG4gIGdyb3VwVGltZXN0YW1wOiB0cnVlLFxuICBsb2NhbGU6IHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UgfHwgJ2VuLVVTJyxcbiAgcmVmZXJlbmNlR3JhbW1hcklEOiAnJyxcbiAgcmVuZGVyTWFya2Rvd246IHRleHQgPT4gdGV4dCxcbiAgc2VuZFRpbWVvdXQ6IDIwMDAwLFxuICBzZW5kVHlwaW5nOiB1bmRlZmluZWQsXG4gIHNlbmRUeXBpbmdJbmRpY2F0b3I6IGZhbHNlLFxuICBzdG9yZTogdW5kZWZpbmVkLFxuICBzdHlsZU9wdGlvbnM6IHt9LFxuICB1c2VySUQ6ICcnLFxuICB1c2VybmFtZTogJycsXG4gIHdlYlNwZWVjaFBvbnlmaWxsRmFjdG9yeTogdW5kZWZpbmVkXG59O1xuXG5Db21wb3Nlci5wcm9wVHlwZXMgPSB7XG4gIGFjdGl2aXR5UmVuZGVyZXI6IFByb3BUeXBlcy5mdW5jLFxuICBhZGFwdGl2ZUNhcmRIb3N0Q29uZmlnOiBQcm9wVHlwZXMuYW55LFxuICBhdHRhY2htZW50UmVuZGVyZXI6IFByb3BUeXBlcy5mdW5jLFxuICBjYXJkQWN0aW9uTWlkZGxld2FyZTogUHJvcFR5cGVzLmZ1bmMsXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMuYW55LFxuICBkaXJlY3RMaW5lOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGFjdGl2aXR5JDogUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIHN1YnNjcmliZTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZFxuICAgIH0pLmlzUmVxdWlyZWQsXG4gICAgY29ubmVjdGlvblN0YXR1cyQ6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgICBzdWJzY3JpYmU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWRcbiAgICB9KS5pc1JlcXVpcmVkLFxuICAgIGVuZDogUHJvcFR5cGVzLmZ1bmMsXG4gICAgZ2V0U2Vzc2lvbklkOiBQcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkLFxuICAgIHBvc3RBY3Rpdml0eTogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgICByZWZlcmVuY2VHcmFtbWFySUQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gICAgdG9rZW46IFByb3BUeXBlcy5zdHJpbmdcbiAgfSkuaXNSZXF1aXJlZCxcbiAgZGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuICBkaXNwYXRjaDogUHJvcFR5cGVzLmZ1bmMuaXNSZXF1aXJlZCxcbiAgZ3JhbW1hcnM6IFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpLFxuICBncm91cFRpbWVzdGFtcDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgbG9jYWxlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICByZWZlcmVuY2VHcmFtbWFySUQ6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHJlbmRlck1hcmtkb3duOiBQcm9wVHlwZXMuZnVuYyxcbiAgc2Nyb2xsVG9FbmQ6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHNlbmRUaW1lb3V0OiBQcm9wVHlwZXMubnVtYmVyLFxuICBzZW5kVHlwaW5nOiBQcm9wVHlwZXMuYm9vbCxcbiAgc2VuZFR5cGluZ0luZGljYXRvcjogUHJvcFR5cGVzLmJvb2wsXG4gIHN0b3JlOiBQcm9wVHlwZXMuYW55LFxuICBzdHlsZU9wdGlvbnM6IFByb3BUeXBlcy5hbnksXG4gIHVzZXJJRDogUHJvcFR5cGVzLnN0cmluZyxcbiAgdXNlcm5hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIHdlYlNwZWVjaFBvbnlmaWxsRmFjdG9yeTogUHJvcFR5cGVzLmZ1bmNcbn07XG4iXX0=