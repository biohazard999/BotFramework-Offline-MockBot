"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = activities;

var _simpleUpdateIn = _interopRequireDefault(require("simple-update-in"));

var _deleteActivity = require("../actions/deleteActivity");

var _incomingActivity = require("../actions/incomingActivity");

var _markActivity = require("../actions/markActivity");

var _postActivity = require("../actions/postActivity");

var _ActivityClientState = require("../constants/ActivityClientState");

/* eslint no-magic-numbers: ["error", { "ignore": [0, -1] }] */
var DEFAULT_STATE = [];

function getClientActivityID(_ref) {
  var _ref$channelData = _ref.channelData;
  _ref$channelData = _ref$channelData === void 0 ? {} : _ref$channelData;
  var clientActivityID = _ref$channelData.clientActivityID;
  return clientActivityID;
}

function findByClientActivityID(clientActivityID) {
  return function (activity) {
    return getClientActivityID(activity) === clientActivityID;
  };
}

function upsertActivityWithSort(activities, nextActivity) {
  var _nextActivity$channel = nextActivity.channelData;
  _nextActivity$channel = _nextActivity$channel === void 0 ? {} : _nextActivity$channel;
  var nextClientActivityID = _nextActivity$channel.clientActivityID,
      _nextActivity$from = nextActivity.from;
  _nextActivity$from = _nextActivity$from === void 0 ? {} : _nextActivity$from;
  var nextFromID = _nextActivity$from.id,
      nextFromRole = _nextActivity$from.role,
      nextType = nextActivity.type;

  if (nextType === 'typing' && nextFromRole === 'user') {
    return activities;
  }

  var nextTimestamp = Date.parse(nextActivity.timestamp);
  var nextActivities = activities.filter(function (_ref2) {
    var _ref2$channelData = _ref2.channelData;
    _ref2$channelData = _ref2$channelData === void 0 ? {} : _ref2$channelData;
    var clientActivityID = _ref2$channelData.clientActivityID,
        from = _ref2.from,
        type = _ref2.type;
    return (// We will remove all "typing" and "sending messages" activities
      // "clientActivityID" is unique and used to track if the message has been sent and echoed back from the server
      !(type === 'typing' && from.id === nextFromID || nextClientActivityID && clientActivityID === nextClientActivityID)
    );
  }); // Then, find the right (sorted) place to insert the new activity at, based on timestamp, and must be before "typing"
  // Since clockskew might happen, we will ignore timestamp on messages that are sending
  // If we are inserting "typing", we will always append it
  // TODO: [P4] Move "typing" into Constants.ActivityType

  var indexToInsert = nextActivity.type === 'typing' ? -1 : nextActivities.findIndex(function (_ref3) {
    var _ref3$channelData = _ref3.channelData;
    _ref3$channelData = _ref3$channelData === void 0 ? {} : _ref3$channelData;
    var state = _ref3$channelData.state,
        timestamp = _ref3.timestamp,
        type = _ref3.type;
    return Date.parse(timestamp) > nextTimestamp && state !== _ActivityClientState.SENDING && state !== _ActivityClientState.SEND_FAILED || type === 'typing';
  }); // If no right place are found, append it

  nextActivities.splice(~indexToInsert ? indexToInsert : nextActivities.length, 0, nextActivity);
  return nextActivities;
}

function activities() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_STATE;

  var _ref4 = arguments.length > 1 ? arguments[1] : undefined,
      meta = _ref4.meta,
      payload = _ref4.payload,
      type = _ref4.type;

  switch (type) {
    case _deleteActivity.DELETE_ACTIVITY:
      state = (0, _simpleUpdateIn["default"])(state, [function (_ref5) {
        var id = _ref5.id;
        return id === payload.activityID;
      }]);
      break;

    case _markActivity.MARK_ACTIVITY:
      state = (0, _simpleUpdateIn["default"])(state, [function (_ref6) {
        var id = _ref6.id;
        return id === payload.activityID;
      }, 'channelData', payload.name], function () {
        return payload.value;
      });
      break;

    case _postActivity.POST_ACTIVITY_PENDING:
      state = upsertActivityWithSort(state, (0, _simpleUpdateIn["default"])(payload.activity, ['channelData', 'state'], function () {
        return _ActivityClientState.SENDING;
      }));
      break;

    case _postActivity.POST_ACTIVITY_REJECTED:
      state = (0, _simpleUpdateIn["default"])(state, [findByClientActivityID(meta.clientActivityID), 'channelData', 'state'], function () {
        return _ActivityClientState.SEND_FAILED;
      });
      break;

    case _postActivity.POST_ACTIVITY_FULFILLED:
      state = (0, _simpleUpdateIn["default"])(state, [findByClientActivityID(meta.clientActivityID)], function () {
        return (// We will replace the activity with the version from the server
          (0, _simpleUpdateIn["default"])(payload.activity, ['channelData', 'state'], function () {
            return _ActivityClientState.SENT;
          })
        );
      });
      break;

    case _incomingActivity.INCOMING_ACTIVITY:
      // UpdateActivity is not supported right now because we ignore duplicated activity ID
      if (!~state.findIndex(function (_ref7) {
        var id = _ref7.id;
        return id === payload.activity.id;
      })) {
        state = upsertActivityWithSort(state, payload.activity);
      }

      break;

    default:
      break;
  }

  return state;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9yZWR1Y2Vycy9hY3Rpdml0aWVzLmpzIl0sIm5hbWVzIjpbIkRFRkFVTFRfU1RBVEUiLCJnZXRDbGllbnRBY3Rpdml0eUlEIiwiY2hhbm5lbERhdGEiLCJjbGllbnRBY3Rpdml0eUlEIiwiZmluZEJ5Q2xpZW50QWN0aXZpdHlJRCIsImFjdGl2aXR5IiwidXBzZXJ0QWN0aXZpdHlXaXRoU29ydCIsImFjdGl2aXRpZXMiLCJuZXh0QWN0aXZpdHkiLCJuZXh0Q2xpZW50QWN0aXZpdHlJRCIsImZyb20iLCJuZXh0RnJvbUlEIiwiaWQiLCJuZXh0RnJvbVJvbGUiLCJyb2xlIiwibmV4dFR5cGUiLCJ0eXBlIiwibmV4dFRpbWVzdGFtcCIsIkRhdGUiLCJwYXJzZSIsInRpbWVzdGFtcCIsIm5leHRBY3Rpdml0aWVzIiwiZmlsdGVyIiwiaW5kZXhUb0luc2VydCIsImZpbmRJbmRleCIsInN0YXRlIiwiU0VORElORyIsIlNFTkRfRkFJTEVEIiwic3BsaWNlIiwibGVuZ3RoIiwibWV0YSIsInBheWxvYWQiLCJERUxFVEVfQUNUSVZJVFkiLCJhY3Rpdml0eUlEIiwiTUFSS19BQ1RJVklUWSIsIm5hbWUiLCJ2YWx1ZSIsIlBPU1RfQUNUSVZJVFlfUEVORElORyIsIlBPU1RfQUNUSVZJVFlfUkVKRUNURUQiLCJQT1NUX0FDVElWSVRZX0ZVTEZJTExFRCIsIlNFTlQiLCJJTkNPTUlOR19BQ1RJVklUWSJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBRUE7O0FBRUE7O0FBQ0E7O0FBQ0E7O0FBRUE7O0FBRUE7O0FBVkE7QUFZQSxJQUFNQSxhQUFhLEdBQUcsRUFBdEI7O0FBRUEsU0FBU0MsbUJBQVQsT0FBeUU7QUFBQSw4QkFBMUNDLFdBQTBDO0FBQUEsbURBQU4sRUFBTTtBQUFBLE1BQTNCQyxnQkFBMkIsb0JBQTNCQSxnQkFBMkI7QUFDdkUsU0FBT0EsZ0JBQVA7QUFDRDs7QUFFRCxTQUFTQyxzQkFBVCxDQUFnQ0QsZ0JBQWhDLEVBQWtEO0FBQ2hELFNBQU8s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QUFBLEtBQUssR0FBR25CLHNCQUFzQixDQUFDbUIsS0FBRCxFQUFRTSxPQUFPLENBQUMxQixRQUFoQixDQUE5QjtBQUNEOztBQUVEOztBQUVGO0FBQ0U7QUExQ0o7O0FBNkNBLFNBQU9vQixLQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tbWFnaWMtbnVtYmVyczogW1wiZXJyb3JcIiwgeyBcImlnbm9yZVwiOiBbMCwgLTFdIH1dICovXG5cbmltcG9ydCB1cGRhdGVJbiBmcm9tICdzaW1wbGUtdXBkYXRlLWluJztcblxuaW1wb3J0IHsgREVMRVRFX0FDVElWSVRZIH0gZnJvbSAnLi4vYWN0aW9ucy9kZWxldGVBY3Rpdml0eSc7XG5pbXBvcnQgeyBJTkNPTUlOR19BQ1RJVklUWSB9IGZyb20gJy4uL2FjdGlvbnMvaW5jb21pbmdBY3Rpdml0eSc7XG5pbXBvcnQgeyBNQVJLX0FDVElWSVRZIH0gZnJvbSAnLi4vYWN0aW9ucy9tYXJrQWN0aXZpdHknO1xuXG5pbXBvcnQgeyBQT1NUX0FDVElWSVRZX0ZVTEZJTExFRCwgUE9TVF9BQ1RJVklUWV9QRU5ESU5HLCBQT1NUX0FDVElWSVRZX1JFSkVDVEVEIH0gZnJvbSAnLi4vYWN0aW9ucy9wb3N0QWN0aXZpdHknO1xuXG5pbXBvcnQgeyBTRU5EX0ZBSUxFRCwgU0VORElORywgU0VOVCB9IGZyb20gJy4uL2NvbnN0YW50cy9BY3Rpdml0eUNsaWVudFN0YXRlJztcblxuY29uc3QgREVGQVVMVF9TVEFURSA9IFtdO1xuXG5mdW5jdGlvbiBnZXRDbGllbnRBY3Rpdml0eUlEKHsgY2hhbm5lbERhdGE6IHsgY2xpZW50QWN0aXZpdHlJRCB9ID0ge30gfSkge1xuICByZXR1cm4gY2xpZW50QWN0aXZpdHlJRDtcbn1cblxuZnVuY3Rpb24gZmluZEJ5Q2xpZW50QWN0aXZpdHlJRChjbGllbnRBY3Rpdml0eUlEKSB7XG4gIHJldHVybiBhY3Rpdml0eSA9PiBnZXRDbGllbnRBY3Rpdml0eUlEKGFjdGl2aXR5KSA9PT0gY2xpZW50QWN0aXZpdHlJRDtcbn1cblxuZnVuY3Rpb24gdXBzZXJ0QWN0aXZpdHlXaXRoU29ydChhY3Rpdml0aWVzLCBuZXh0QWN0aXZpdHkpIHtcbiAgY29uc3Qge1xuICAgIGNoYW5uZWxEYXRhOiB7IGNsaWVudEFjdGl2aXR5SUQ6IG5leHRDbGllbnRBY3Rpdml0eUlEIH0gPSB7fSxcbiAgICBmcm9tOiB7IGlkOiBuZXh0RnJvbUlELCByb2xlOiBuZXh0RnJvbVJvbGUgfSA9IHt9LFxuICAgIHR5cGU6IG5leHRUeXBlXG4gIH0gPSBuZXh0QWN0aXZpdHk7XG5cbiAgaWYgKG5leHRUeXBlID09PSAndHlwaW5nJyAmJiBuZXh0RnJvbVJvbGUgPT09ICd1c2VyJykge1xuICAgIHJldHVybiBhY3Rpdml0aWVzO1xuICB9XG5cbiAgY29uc3QgbmV4dFRpbWVzdGFtcCA9IERhdGUucGFyc2UobmV4dEFjdGl2aXR5LnRpbWVzdGFtcCk7XG4gIGNvbnN0IG5leHRBY3Rpdml0aWVzID0gYWN0aXZpdGllcy5maWx0ZXIoXG4gICAgKHsgY2hhbm5lbERhdGE6IHsgY2xpZW50QWN0aXZpdHlJRCB9ID0ge30sIGZyb20sIHR5cGUgfSkgPT5cbiAgICAgIC8vIFdlIHdpbGwgcmVtb3ZlIGFsbCBcInR5cGluZ1wiIGFuZCBcInNlbmRpbmcgbWVzc2FnZXNcIiBhY3Rpdml0aWVzXG4gICAgICAvLyBcImNsaWVudEFjdGl2aXR5SURcIiBpcyB1bmlxdWUgYW5kIHVzZWQgdG8gdHJhY2sgaWYgdGhlIG1lc3NhZ2UgaGFzIGJlZW4gc2VudCBhbmQgZWNob2VkIGJhY2sgZnJvbSB0aGUgc2VydmVyXG4gICAgICAhKFxuICAgICAgICAodHlwZSA9PT0gJ3R5cGluZycgJiYgZnJvbS5pZCA9PT0gbmV4dEZyb21JRCkgfHxcbiAgICAgICAgKG5leHRDbGllbnRBY3Rpdml0eUlEICYmIGNsaWVudEFjdGl2aXR5SUQgPT09IG5leHRDbGllbnRBY3Rpdml0eUlEKVxuICAgICAgKVxuICApO1xuXG4gIC8vIFRoZW4sIGZpbmQgdGhlIHJpZ2h0IChzb3J0ZWQpIHBsYWNlIHRvIGluc2VydCB0aGUgbmV3IGFjdGl2aXR5IGF0LCBiYXNlZCBvbiB0aW1lc3RhbXAsIGFuZCBtdXN0IGJlIGJlZm9yZSBcInR5cGluZ1wiXG4gIC8vIFNpbmNlIGNsb2Nrc2tldyBtaWdodCBoYXBwZW4sIHdlIHdpbGwgaWdub3JlIHRpbWVzdGFtcCBvbiBtZXNzYWdlcyB0aGF0IGFyZSBzZW5kaW5nXG4gIC8vIElmIHdlIGFyZSBpbnNlcnRpbmcgXCJ0eXBpbmdcIiwgd2Ugd2lsbCBhbHdheXMgYXBwZW5kIGl0XG5cbiAgLy8gVE9ETzogW1A0XSBNb3ZlIFwidHlwaW5nXCIgaW50byBDb25zdGFudHMuQWN0aXZpdHlUeXBlXG4gIGNvbnN0IGluZGV4VG9JbnNlcnQgPVxuICAgIG5leHRBY3Rpdml0eS50eXBlID09PSAndHlwaW5nJ1xuICAgICAgPyAtMVxuICAgICAgOiBuZXh0QWN0aXZpdGllcy5maW5kSW5kZXgoXG4gICAgICAgICAgKHsgY2hhbm5lbERhdGE6IHsgc3RhdGUgfSA9IHt9LCB0aW1lc3RhbXAsIHR5cGUgfSkgPT5cbiAgICAgICAgICAgIChEYXRlLnBhcnNlKHRpbWVzdGFtcCkgPiBuZXh0VGltZXN0YW1wICYmIHN0YXRlICE9PSBTRU5ESU5HICYmIHN0YXRlICE9PSBTRU5EX0ZBSUxFRCkgfHwgdHlwZSA9PT0gJ3R5cGluZydcbiAgICAgICAgKTtcblxuICAvLyBJZiBubyByaWdodCBwbGFjZSBhcmUgZm91bmQsIGFwcGVuZCBpdFxuICBuZXh0QWN0aXZpdGllcy5zcGxpY2UofmluZGV4VG9JbnNlcnQgPyBpbmRleFRvSW5zZXJ0IDogbmV4dEFjdGl2aXRpZXMubGVuZ3RoLCAwLCBuZXh0QWN0aXZpdHkpO1xuXG4gIHJldHVybiBuZXh0QWN0aXZpdGllcztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gYWN0aXZpdGllcyhzdGF0ZSA9IERFRkFVTFRfU1RBVEUsIHsgbWV0YSwgcGF5bG9hZCwgdHlwZSB9KSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgREVMRVRFX0FDVElWSVRZOlxuICAgICAgc3RhdGUgPSB1cGRhdGVJbihzdGF0ZSwgWyh7IGlkIH0pID0+IGlkID09PSBwYXlsb2FkLmFjdGl2aXR5SURdKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBNQVJLX0FDVElWSVRZOlxuICAgICAgc3RhdGUgPSB1cGRhdGVJbihcbiAgICAgICAgc3RhdGUsXG4gICAgICAgIFsoeyBpZCB9KSA9PiBpZCA9PT0gcGF5bG9hZC5hY3Rpdml0eUlELCAnY2hhbm5lbERhdGEnLCBwYXlsb2FkLm5hbWVdLFxuICAgICAgICAoKSA9PiBwYXlsb2FkLnZhbHVlXG4gICAgICApO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFBPU1RfQUNUSVZJVFlfUEVORElORzpcbiAgICAgIHN0YXRlID0gdXBzZXJ0QWN0aXZpdHlXaXRoU29ydChzdGF0ZSwgdXBkYXRlSW4ocGF5bG9hZC5hY3Rpdml0eSwgWydjaGFubmVsRGF0YScsICdzdGF0ZSddLCAoKSA9PiBTRU5ESU5HKSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgUE9TVF9BQ1RJVklUWV9SRUpFQ1RFRDpcbiAgICAgIHN0YXRlID0gdXBkYXRlSW4oXG4gICAgICAgIHN0YXRlLFxuICAgICAgICBbZmluZEJ5Q2xpZW50QWN0aXZpdHlJRChtZXRhLmNsaWVudEFjdGl2aXR5SUQpLCAnY2hhbm5lbERhdGEnLCAnc3RhdGUnXSxcbiAgICAgICAgKCkgPT4gU0VORF9GQUlMRURcbiAgICAgICk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgUE9TVF9BQ1RJVklUWV9GVUxGSUxMRUQ6XG4gICAgICBzdGF0ZSA9IHVwZGF0ZUluKHN0YXRlLCBbZmluZEJ5Q2xpZW50QWN0aXZpdHlJRChtZXRhLmNsaWVudEFjdGl2aXR5SUQpXSwgKCkgPT5cbiAgICAgICAgLy8gV2Ugd2lsbCByZXBsYWNlIHRoZSBhY3Rpdml0eSB3aXRoIHRoZSB2ZXJzaW9uIGZyb20gdGhlIHNlcnZlclxuICAgICAgICB1cGRhdGVJbihwYXlsb2FkLmFjdGl2aXR5LCBbJ2NoYW5uZWxEYXRhJywgJ3N0YXRlJ10sICgpID0+IFNFTlQpXG4gICAgICApO1xuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSU5DT01JTkdfQUNUSVZJVFk6XG4gICAgICAvLyBVcGRhdGVBY3Rpdml0eSBpcyBub3Qgc3VwcG9ydGVkIHJpZ2h0IG5vdyBiZWNhdXNlIHdlIGlnbm9yZSBkdXBsaWNhdGVkIGFjdGl2aXR5IElEXG4gICAgICBpZiAoIX5zdGF0ZS5maW5kSW5kZXgoKHsgaWQgfSkgPT4gaWQgPT09IHBheWxvYWQuYWN0aXZpdHkuaWQpKSB7XG4gICAgICAgIHN0YXRlID0gdXBzZXJ0QWN0aXZpdHlXaXRoU29ydChzdGF0ZSwgcGF5bG9hZC5hY3Rpdml0eSk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuIl19